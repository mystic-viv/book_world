import 'dart:io';
import 'package:book_world/models/book_model.dart';
import 'package:book_world/services/supabase_service.dart';
import 'package:flutter/widgets.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:path/path.dart' as path;
import 'package:uuid/uuid.dart';

class BookService {
  static final supabase = Supabase.instance.client;
  static final uuid = Uuid();

  // Upload a new book (for librarians)
  static Future<Map<String, dynamic>> uploadBook({
    required String bookName,
    required String authorName,
    required String description,
    required int totalCopies, // Changed from totalCopies
    List<String>? genres, // Added genres parameter
    int? publicationYear, // Added publication year
    File? coverImage,
    File? ebookFile,
  }) async {
    try {
      // Insert book record first to get the custom_id generated by the trigger
      final response =
          await supabase
              .from('books')
              .insert({
                'book_name': bookName,
                'author_name': authorName,
                'description': description,
                'genres': genres,
                'total_copies': totalCopies,
                'available_copies': totalCopies,
                'publication_year': publicationYear,
                'is_ebook': ebookFile != null,
              })
              .select('custom_id')
              .single();

      final String customId = response['custom_id'];

      // Upload cover image if provided
      String? bookCoverUrl;
      if (coverImage != null) {
        final fileExt = path.extension(coverImage.path);
        final fileName = '$customId$fileExt';

        await supabase.storage.from('book_covers').upload(fileName, coverImage);

        bookCoverUrl = supabase.storage
            .from('book_covers')
            .getPublicUrl(fileName);
      }

      // Upload ebook file if provided
      String? bookPdfUrl;
      if (ebookFile != null) {
        final fileExt = path.extension(ebookFile.path);
        final fileName = '$customId$fileExt';

        await supabase.storage.from('ebooks').upload(fileName, ebookFile);

        bookPdfUrl = supabase.storage.from('ebooks').getPublicUrl(fileName);
      }

      // Update the book with the URLs
      await supabase
          .from('books')
          .update({'book_cover_url': bookCoverUrl, 'book_pdf_url': bookPdfUrl})
          .eq('custom_id', customId);

      return {
        'success': true,
        'bookId': customId,
        'message': 'Book uploaded successfully!',
      };
    } catch (e) {
      print('Error uploading book: $e');
      return {
        'success': false,
        'message': 'Failed to upload book: ${e.toString()}',
      };
    }
  }

  // Issue a book (for librarians)
  static Future<Map<String, dynamic>> issueBook(
    String bookId,
    String userId,
  ) async {
    try {
      // Check if book exists and get its details
      final bookResponse =
          await supabase
              .from('books')
              .select('id, available_copies, book_name, is_ebook')
              .eq('custom_id', bookId) // Use custom_id instead of id
              .single();
      if (bookResponse == null) {
        return {'success': false, 'message': 'Book not found.'};
      }

      // Check if the book is already issued to the user
      final issuedBooksResponse =
          await supabase
              .from('issued_books')
              .select('*')
              .eq('user_id', userId)
              .eq('book_id', bookResponse['id'])
              .single();

      if (issuedBooksResponse != null) {
        return {
          'success': false,
          'message': 'Book is already issued to the user.',
        };
      }

      // Check if the book is an ebook
      final bool isEbook = bookResponse['is_ebook'] as bool;
      final int availableCopies = bookResponse['available_copies'] as int;
      final String bookTitle = bookResponse['book_name'] as String;

      // For e-books, we don't need to check or update availability
      // For physical books, we need to check if copies are available
      if (!isEbook && availableCopies <= 0) {
        return {
          'success': false,
          'message': 'No copies of "$bookTitle" available for checkout.',
        };
      }

      // Only update available copies for physical books
      if (!isEbook) {
        await supabase
            .from('books')
            .update({'available_copies': availableCopies - 1})
            .eq('custom_id', bookId); // Use custom_id instead of id
      }

      // Create transaction record
      final transactionId = uuid.v4();
      await supabase.from('book_transactions').insert({
        'id': transactionId,
        'book_id': bookId, // Use internal ID for relationships
        'user_id': userId,
        'issued_at': DateTime.now().toIso8601String(),
        'due_at':
            isEbook
                ? null
                : DateTime.now().add(Duration(days: 14)).toIso8601String(),
        'status': isEbook ? 'accessed' : 'issued',
        'is_ebook': isEbook,
      });

      return {
        'success': true,
        'transactionId': transactionId,
        'message':
            isEbook
                ? 'E-book "$bookTitle" access granted successfully!'
                : 'Book "$bookTitle" issued successfully!',
      };
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to issue book: ${e.toString()}',
      };
    }
  }

  // Return a physical book (for librarians)
  static Future<Map<String, dynamic>> returnBook(String transactionId) async {
    try {
      // Get transaction details
      final transactionResponse =
          await supabase
              .from('book_transactions')
              .select('book_id, status, is_ebook, books(book_name, custom_id)')
              .eq('id', transactionId)
              .single();

      // If it's an e-book, we don't need to handle returns
      if (transactionResponse['is_ebook'] == true) {
        return {
          'success': false,
          'message': 'E-books do not need to be returned',
        };
      }

      if (transactionResponse['status'] != 'issued') {
        return {'success': false, 'message': 'Book is not currently issued'};
      }

      final bookId = transactionResponse['books']['custom_id'] as String;
      final bookTitle = transactionResponse['books']['book_name'] as String;

      // Get current available copies
      final bookResponse =
          await supabase
              .from('books')
              .select('available_copies, total_copies')
              .eq('custom_id', bookId)
              .single();

      final availableCopies = bookResponse['available_copies'] as int;
      final totalCopies = bookResponse['total_copies'] as int;

      // Ensure we don't exceed total copies
      if (availableCopies >= totalCopies) {
        return {
          'success': false,
          'message': 'All copies are already available',
        };
      }

      // Update available copies
      await supabase
          .from('books')
          .update({'available_copies': availableCopies + 1})
          .eq('custom_id', bookId);

      // Update transaction record
      await supabase
          .from('book_transactions')
          .update({
            'returned_at': DateTime.now().toIso8601String(),
            'status': 'returned',
          })
          .eq('id', transactionId);

      return {
        'success': true,
        'message': 'Book "$bookTitle" returned successfully!',
      };
    } catch (e) {
      return {
        'success': false,
        'message': 'Failed to return book: ${e.toString()}',
      };
    }
  }

  // Get all transactions (for librarians)
  static Future<List<Map<String, dynamic>>> getAllTransactions() async {
    try {
      final response = await supabase
          .from('book_transactions')
          .select('*, books(*), users(*)')
          .order('issued_at', ascending: false);

      return (response as List).cast<Map<String, dynamic>>();
    } catch (e) {
      print('Error fetching transactions: $e');
      return [];
    }
  }

  // Get user's borrowed books
  static Future<List<Map<String, dynamic>>> getUserBorrowedBooks(
    String userId,
  ) async {
    try {
      final response = await supabase
          .from('book_transactions')
          .select('*, books(*)')
          .eq('user_id', userId)
          .or('status.eq.issued,status.eq.accessed')
          .order('issued_at', ascending: false);

      return (response as List).cast<Map<String, dynamic>>();
    } catch (e) {
      print('Error fetching user borrowed books: $e');
      return [];
    }
  }

  // Get user's e-book access
  static Future<List<Map<String, dynamic>>> getUserEbooks(String userId) async {
    try {
      final response = await supabase
          .from('book_transactions')
          .select('*, books(*)')
          .eq('user_id', userId)
          .eq('is_ebook', true)
          .order('issued_at', ascending: false);

      return (response as List).cast<Map<String, dynamic>>();
    } catch (e) {
      print('Error fetching user e-books: $e');
      return [];
    }
  }

  // Save & Unsave a book (for users)
  Future<void> saveBook(String bookId) async {
    final userId = supabase.auth.currentUser?.id;
    await supabase.from('saved_books').insert({
      'user_id': userId,
      'book_id': bookId,
    });
  }

  Future<void> unsaveBook(String bookId) async {
    final userId = supabase.auth.currentUser?.id;
    if (userId != null) {
      await supabase.from('saved_books').delete().match({
        'user_id': userId,
        'book_id': bookId,
      });
    }
  }

  Future<bool> isBookSaved(String bookId) async {
    final userId = supabase.auth.currentUser?.id;
    if (userId == null) return false;
    final response = await supabase.from('saved_books').select().match({
      'user_id': userId,
      'book_id': bookId,
    });
    return response.isNotEmpty;
  }

  // Get recently interacted books for the current user
  Future<List<BookModel>> getRecentlyInteractedBooks() async {
    try {
      final userId = supabase.auth.currentUser?.id;
      if (userId == null) return [];

      // First, get the book IDs from interactions with explicit limit
      final interactionsResponse = await supabase
          .from('book_interactions')
          .select('book_id, created_at')
          .eq('user_id', userId)
          .order('created_at', ascending: false);

      debugPrint(
        'Raw interactions response length: ${interactionsResponse.length}',
      );

      // Extract unique book IDs while preserving order
      final List<String> orderedUniqueBookIds = [];
      final Set<String> seenIds = {};

      for (final record in interactionsResponse) {
        final bookId = record['book_id'];
        if (!seenIds.contains(bookId)) {
          seenIds.add(bookId);
          orderedUniqueBookIds.add(bookId);
        }
      }

      debugPrint('Unique book IDs count: ${orderedUniqueBookIds.length}');
      debugPrint('Unique book IDs: $orderedUniqueBookIds');

      if (orderedUniqueBookIds.isEmpty) return [];

      // Then fetch the actual books
      final booksResponse = await supabase
          .from('books')
          .select()
          .inFilter('id', orderedUniqueBookIds);

      debugPrint('Books response length: ${booksResponse.length}');

      // Convert to BookModel objects while preserving order
      final Map<String, BookModel> booksMap = {
        for (var book in booksResponse) book['id']: BookModel.fromJson(book),
      };

      final List<BookModel> orderedBooks =
          orderedUniqueBookIds
              .where((id) => booksMap.containsKey(id))
              .map((id) => booksMap[id]!)
              .toList();

      debugPrint('Final ordered books length: ${orderedBooks.length}');

      return orderedBooks;
    } catch (e) {
      debugPrint('Error fetching recently interacted books: $e');
      return [];
    }
  } // Get recently added books

  Future<List<BookModel>> getRecentlyAddedBooks() async {
    try {
      final response = await supabase
          .from('books')
          .select()
          .order('created_at', ascending: false);

      return response
          .map<BookModel>((book) => BookModel.fromJson(book))
          .toList();
    } catch (e) {
      debugPrint('Error fetching recently added books: $e');
      return [];
    }
  }

  // Get top explored books based on interaction count from all users
  Future<List<BookModel>> getTopExploredBooks() async {
    try {
      // Get ALL books first
      final allBooksResponse = await supabase
          .from('books')
          .select()
          .order('created_at', ascending: false);

      final List<BookModel> allBooks =
          allBooksResponse
              .map<BookModel>((book) => BookModel.fromJson(book))
              .toList();

      if (allBooks.isEmpty) {
        return [];
      }

      // Then get all book interactions
      final interactionsResponse = await supabase
          .from('book_interactions')
          .select('book_id, interaction_type')
          .eq('interaction_type', 'view');

      // Debug print to see what's happening
      debugPrint('All books count: ${allBooks.length}');
      debugPrint('Interactions count: ${interactionsResponse.length}');

      // If no interactions, just return all books
      if (interactionsResponse.isEmpty) {
        return allBooks;
      }

      // Count interactions for each book
      final Map<String, int> bookViewCounts = {};
      for (final interaction in interactionsResponse) {
        final bookId = interaction['book_id'];
        bookViewCounts[bookId] = (bookViewCounts[bookId] ?? 0) + 1;
      }

      // Debug print the view counts
      debugPrint('Book view counts: $bookViewCounts');

      // Create two lists: books with views and books without views
      final List<BookModel> booksWithViews = [];
      final List<BookModel> booksWithoutViews = [];

      for (final book in allBooks) {
        if (bookViewCounts.containsKey(book.id)) {
          booksWithViews.add(book);
        } else {
          booksWithoutViews.add(book);
        }
      }

      // Sort books with views by view count
      booksWithViews.sort((a, b) {
        final viewsA = bookViewCounts[a.id] ?? 0;
        final viewsB = bookViewCounts[b.id] ?? 0;
        return viewsB.compareTo(viewsA);
      });

      // Combine the lists: first books with views, then books without views
      final List<BookModel> result = [...booksWithViews, ...booksWithoutViews];

      debugPrint('Final result count: ${result.length}');
      return result;
    } catch (e) {
      debugPrint('Error fetching top explored books: $e');
      return [];
    }
  }

  // Get all books
  Future<List<BookModel>> getAllBooks() async {
    try {
      final response = await supabase.from('books').select();
      return response
          .map<BookModel>((book) => BookModel.fromJson(book))
          .toList();
    } catch (e) {
      debugPrint('Error fetching all books: $e');
      return [];
    }
  }

  // Search books by title, author, or description
  Future<List<BookModel>> searchBooks(String query) async {
    try {
      final response = await supabase
          .from('books')
          .select()
          .or(
            'book_name.ilike.%$query%,author_name.ilike.%$query%,description.ilike.%$query%',
          )
          .limit(20);

      return response
          .map<BookModel>((book) => BookModel.fromJson(book))
          .toList();
    } catch (e) {
      debugPrint('Error searching books: $e');
      return [];
    }
  }

  // Record a book interaction (view, borrow, etc.)
  Future<void> recordBookInteraction(
    String bookId,
    String interactionType,
  ) async {
    try {
      final userId = supabase.auth.currentUser?.id;
      if (userId == null) return;

      await supabase.from('book_interactions').insert({
        'user_id': userId,
        'book_id': bookId,
        'interaction_type': interactionType,
      });
    } catch (e) {
      debugPrint('Error recording book interaction: $e');
    }
  }

  // Get similar books based on genres
  Future<List<BookModel>> getSimilarBooks({
    required String bookId,
    required List<String> genres,
    int limit = 10,
  }) async {
    try {
      final response = await supabase
          .from('books')
          .select()
          .neq('id', bookId)
          .overlaps('genres', genres)
          .order('created_at', ascending: false)
          .limit(limit);

      final List<BookModel> allSimilarBooks =
          response.map<BookModel>((book) => BookModel.fromJson(book)).toList();

      // Sort by number of matching genres
      allSimilarBooks.sort((a, b) {
        int matchesA = a.genres?.where((g) => genres.contains(g)).length ?? 0;
        int matchesB = b.genres?.where((g) => genres.contains(g)).length ?? 0;
        return matchesB.compareTo(matchesA);
      });

      return allSimilarBooks;
    } catch (e) {
      debugPrint('Error fetching similar books: $e');
      return [];
    }
  }

  Future<BookModel> getBookById(String bookId) async {
    try {
      final response = await SupabaseService.client
          ?.from('books')
          .select()
          .eq('id', bookId)
          .single();

      if (response == null) {
        throw Exception('Book not found');
      }

      return BookModel.fromJson(response);
    } catch (e) {
      throw Exception('Failed to fetch book: $e');
    }
  }

  // Update book model to include PDF URL
  Future<List<BookModel>> getBooksWithPdf() async {
    try {
      final response = await supabase
          .from('books')
          .select()
          .not('book_pdf_url', 'is', null);

      // Handle the response based on the current Supabase client version
      if (response == null) {
        return [];
      }

      return (response as List)
          .map((json) => BookModel.fromJson(json))
          .toList();
    } catch (e) {
      debugPrint('Error fetching books with PDF: $e');
      throw Exception('Failed to fetch books with PDF: $e');
    }
  }
}
